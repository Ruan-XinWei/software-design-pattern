# 基于Java实现的软件设计模式

## [单例模式](src/Singleton)

### 模式动机
对于系统中的某些类来说，有且只能有一个实例。例如：一个系统只能有一个窗口管理器。系统中可以有许多打印机，但是只能有一个打印机正在工作。

我们怎样保证一个类只有一个实例并且这个实例易于被访问呢？

> 让类自身负责保存它的唯一实例。这个类可以保证没有其它实例被创建，并且它可以提供一个访问该实例的方法。这就是单例模式——Singleton Pattern。

### 模式定义

单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。

单例模式的要点:
1. 某个类只能有一个实例； 
2. 它必须自行创建这个实例；
3. 它必须自行向整个系统提供这个实例。

### 模式结构

![img_3.png](img_3.png)

### 模式分析

1. 私有化构造方法
2. 提供获取实例的方法
3. 获取实例的静态方法
4. 定义存储实例的属性
5. 把这个属性也定义成静态
6. 实现控制实例的创建

### 模式优缺点

模式优点：
1. 提供了对唯一实例的受控访问。 
2. 由于系统中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。
3. 允许可变数目的实例。可以对单例模式进行扩展，设计指定个数的实例对象，即节省系统资源，又解决了由于单例对象共享过多有损性能的问题。
   
模式缺点：
1. 由于单例模式中没有抽象层，因此单例类的扩展有很大困难。 
2. 单例类的职责过重，在一定程度上违背了单一指责原则。因为单例模式即提供业务方法，又提供了创建对象的方法，将对象功能和创建耦合在一起。
3. 很多面向对象语言的GC垃圾回收技术，实例化的对象长期不使用，系统会认为是垃圾，自动销毁并回收资源，这将导致共享的单例对象状态的丢失。


### 模式使用情况

1. 系统只需要一个实例对象。例如，系统要求提供一个唯一的系列号生成器或资源管理器，或资源消耗太大而只允许创建一个对象。 
2. 客户调用类的单个实例只允许使用一个公共访问点。

### 模式扩展

1. 使用同步锁，解决高并发问题
2. 饿汉式单例
   > 懒汉式单例就是这个单例类的这个唯一实例new是在第一次使用 GetInstance()时实例化的 
   > 如果不调用 GetInstance()的话，这个实例是不会存在的，即为 null 
   > 形象点说呢，就是你不去动它的话，它自己是不会实例化的，所以可以称之为懒汉。
3. 懒汉式单例
   > 饿汉式单例的话，则刚好相反， 
   > 其由于肚子饿了，所以到处找东西吃，人也变得主动了很多，所以根本就不需要别人来催他实例化单例类的为一实例， 
   > 其自己就会主动实例化单例类的这个唯一类。
4. 管理多个对象

